// Generated by CoffeeScript 1.12.7
var async, check_order, dicer, express, grid, gridLocks, mongodb, resumable_get_handler, resumable_get_lookup, resumable_post_handler, resumable_post_lookup;

import share from './share.js';

if (Meteor.isServer) {
  express = Npm.require('express');
  mongodb = Npm.require('mongodb');
  grid = Npm.require('gridfs-locking-stream');
  gridLocks = Npm.require('gridfs-locks');
  dicer = Npm.require('dicer');
  async = Npm.require('async');
  check_order = function(file, callback) {
    var fileId, lock;
    fileId = mongodb.ObjectID("" + file.metadata._Resumable.resumableIdentifier);
    lock = gridLocks.Lock(fileId, this.locks, {}).obtainWriteLock();
    lock.on('locked', (function(_this) {
      return function() {
        var cursor, files;
        files = _this.db.collection(_this.root + ".files");
        cursor = files.find({
          'metadata._Resumable.resumableIdentifier': file.metadata._Resumable.resumableIdentifier,
          length: {
            $ne: 0
          }
        }, {
          fields: {
            length: 1,
            metadata: 1
          },
          sort: {
            'metadata._Resumable.resumableChunkNumber': 1
          }
        });
        return cursor.count(function(err, count) {
          var chunks;
          if (err) {
            lock.releaseLock();
            return callback(err);
          }
          if (!(count >= 1)) {
            cursor.close();
            lock.releaseLock();
            return callback();
          }
          if (count !== file.metadata._Resumable.resumableTotalChunks) {
            cursor.close();
            lock.releaseLock();
            return callback();
          }
          chunks = _this.db.collection(_this.root + ".chunks");
          cursor.batchSize(file.metadata._Resumable.resumableTotalChunks + 1);
          return cursor.toArray(function(err, parts) {
            if (err) {
              lock.releaseLock();
              return callback(err);
            }
            return async.eachLimit(parts, 5, function(part, cb) {
              var partId, partlock;
              if (err) {
                console.error("Error from cursor.next()", err);
                cb(err);
              }
              if (!part) {
                return cb(new Meteor.Error("Received null part"));
              }
              partId = mongodb.ObjectID("" + part._id);
              partlock = gridLocks.Lock(partId, _this.locks, {}).obtainWriteLock();
              partlock.on('locked', function() {
                return async.series([
                  function(cb) {
                    return chunks.update({
                      files_id: partId,
                      n: 0
                    }, {
                      $set: {
                        files_id: fileId,
                        n: part.metadata._Resumable.resumableChunkNumber - 1
                      }
                    }, cb);
                  }, function(cb) {
                    return files.remove({
                      _id: partId
                    }, cb);
                  }
                ], function(err, res) {
                  if (err) {
                    return cb(err);
                  }
                  if (part.metadata._Resumable.resumableChunkNumber !== part.metadata._Resumable.resumableTotalChunks) {
                    partlock.removeLock();
                    return cb();
                  } else {
                    return chunks.update({
                      files_id: partId,
                      n: 1
                    }, {
                      $set: {
                        files_id: fileId,
                        n: part.metadata._Resumable.resumableChunkNumber
                      }
                    }, function(err, res) {
                      partlock.removeLock();
                      if (err) {
                        return cb(err);
                      }
                      return cb();
                    });
                  }
                });
              });
              partlock.on('timed-out', function() {
                return cb(new Meteor.Error('Partlock timed out!'));
              });
              partlock.on('expired', function() {
                return cb(new Meteor.Error('Partlock expired!'));
              });
              return partlock.on('error', function(err) {
                console.error("Error obtaining partlock " + part._id, err);
                return cb(err);
              });
            }, function(err) {
              var md5Command;
              if (err) {
                lock.releaseLock();
                return callback(err);
              }
              md5Command = {
                filemd5: fileId,
                root: "" + _this.root
              };
              return _this.db.command(md5Command, function(err, results) {
                if (err) {
                  lock.releaseLock();
                  return callback(err);
                }
                return files.update({
                  _id: fileId
                }, {
                  $set: {
                    length: file.metadata._Resumable.resumableTotalSize,
                    md5: results.md5
                  }
                }, (function(_this) {
                  return function(err, res) {
                    lock.releaseLock();
                    return callback(err);
                  };
                })(this));
              });
            });
          });
        });
      };
    })(this));
    lock.on('expires-soon', function() {
      return lock.renewLock().once('renewed', function(ld) {
        if (!ld) {
          return console.warn("Resumable upload lock renewal failed!");
        }
      });
    });
    lock.on('expired', function() {
      return callback(new Meteor.Error("File Lock expired"));
    });
    lock.on('timed-out', function() {
      return callback(new Meteor.Error("File Lock timed out"));
    });
    return lock.on('error', function(err) {
      return callback(err);
    });
  };
  resumable_post_lookup = function(params, query, multipart) {
    var ref;
    return {
      _id: share.safeObjectID(multipart != null ? (ref = multipart.params) != null ? ref.resumableIdentifier : void 0 : void 0)
    };
  };
  resumable_post_handler = function(req, res, next) {
    var chunkQuery, findResult, ref, ref1, resumable, writeStream;
    if (!((ref = req.multipart) != null ? (ref1 = ref.params) != null ? ref1.resumableIdentifier : void 0 : void 0)) {
      console.error("Missing resumable.js multipart information");
      res.writeHead(501, share.defaultResponseHeaders);
      res.end();
      return;
    }
    resumable = req.multipart.params;
    resumable.resumableTotalSize = parseInt(resumable.resumableTotalSize);
    resumable.resumableTotalChunks = parseInt(resumable.resumableTotalChunks);
    resumable.resumableChunkNumber = parseInt(resumable.resumableChunkNumber);
    resumable.resumableChunkSize = parseInt(resumable.resumableChunkSize);
    resumable.resumableCurrentChunkSize = parseInt(resumable.resumableCurrentChunkSize);
    if (req.maxUploadSize > 0) {
      if (!(resumable.resumableTotalSize <= req.maxUploadSize)) {
        res.writeHead(413, share.defaultResponseHeaders);
        res.end();
        return;
      }
    }
    if (!((req.gridFS.chunkSize === resumable.resumableChunkSize) && (resumable.resumableChunkNumber <= resumable.resumableTotalChunks) && (resumable.resumableTotalSize / resumable.resumableChunkSize <= resumable.resumableTotalChunks + 1) && (resumable.resumableCurrentChunkSize === resumable.resumableChunkSize) || ((resumable.resumableChunkNumber === resumable.resumableTotalChunks) && (resumable.resumableCurrentChunkSize < 2 * resumable.resumableChunkSize)))) {
      res.writeHead(501, share.defaultResponseHeaders);
      res.end();
      return;
    }
    chunkQuery = {
      length: resumable.resumableCurrentChunkSize,
      'metadata._Resumable.resumableIdentifier': resumable.resumableIdentifier,
      'metadata._Resumable.resumableChunkNumber': resumable.resumableChunkNumber
    };
    findResult = this.findOne(chunkQuery, {
      fields: {
        _id: 1
      }
    });
    if (findResult) {
      res.writeHead(200, share.defaultResponseHeaders);
      return res.end();
    } else {
      req.gridFS.metadata._Resumable = resumable;
      writeStream = this.upsertStream({
        filename: "_Resumable_" + resumable.resumableIdentifier + "_" + resumable.resumableChunkNumber + "_" + resumable.resumableTotalChunks,
        metadata: req.gridFS.metadata
      });
      if (!writeStream) {
        res.writeHead(404, share.defaultResponseHeaders);
        res.end();
        return;
      }
      return req.multipart.fileStream.pipe(share.streamChunker(this.chunkSize)).pipe(writeStream).on('close', share.bind_env((function(_this) {
        return function(retFile) {
          if (retFile) {
            return check_order.bind(_this)(req.gridFS, function(err) {
              if (err) {
                console.error("Error reassembling chunks of resumable.js upload", err);
                res.writeHead(500, share.defaultResponseHeaders);
              } else {
                res.writeHead(200, share.defaultResponseHeaders);
              }
              return res.end();
            });
          } else {
            console.error("Missing retFile on pipe close");
            res.writeHead(500, share.defaultResponseHeaders);
            return res.end();
          }
        };
      })(this))).on('error', share.bind_env((function(_this) {
        return function(err) {
          console.error("Piping Error!", err);
          res.writeHead(500, share.defaultResponseHeaders);
          return res.end();
        };
      })(this)));
    }
  };
  resumable_get_lookup = function(params, query) {
    var q;
    q = {
      _id: share.safeObjectID(query.resumableIdentifier)
    };
    return q;
  };
  resumable_get_handler = function(req, res, next) {
    var chunkQuery, query, result;
    query = req.query;
    chunkQuery = {
      $or: [
        {
          _id: share.safeObjectID(query.resumableIdentifier),
          length: parseInt(query.resumableTotalSize)
        }, {
          length: parseInt(query.resumableCurrentChunkSize),
          'metadata._Resumable.resumableIdentifier': query.resumableIdentifier,
          'metadata._Resumable.resumableChunkNumber': parseInt(query.resumableChunkNumber)
        }
      ]
    };
    result = this.findOne(chunkQuery, {
      fields: {
        _id: 1
      }
    });
    if (result) {
      res.writeHead(200, share.defaultResponseHeaders);
    } else {
      res.writeHead(204, share.defaultResponseHeaders);
    }
    return res.end();
  };
  share.resumablePaths = [
    {
      method: 'head',
      path: share.resumableBase,
      lookup: resumable_get_lookup,
      handler: resumable_get_handler
    }, {
      method: 'post',
      path: share.resumableBase,
      lookup: resumable_post_lookup,
      handler: resumable_post_handler
    }, {
      method: 'get',
      path: share.resumableBase,
      lookup: resumable_get_lookup,
      handler: resumable_get_handler
    }
  ];
}

// Generated by CoffeeScript 1.12.7
var build_access_point, cookieParser, del, dice_multipart, dicer, express, find_mime_boundary, get, grid, gridLocks, handle_auth, lookup_userId_by_token, mongodb, post, put;

import share from './share.js';

if (Meteor.isServer) {
  express = Npm.require('express');
  cookieParser = Npm.require('cookie-parser');
  mongodb = Npm.require('mongodb');
  grid = Npm.require('gridfs-locking-stream');
  gridLocks = Npm.require('gridfs-locks');
  dicer = Npm.require('dicer');
  find_mime_boundary = function(req) {
    var RE_BOUNDARY, result;
    RE_BOUNDARY = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i;
    result = RE_BOUNDARY.exec(req.headers['content-type']);
    return (result != null ? result[1] : void 0) || (result != null ? result[2] : void 0);
  };
  dice_multipart = function(req, res, next) {
    var boundary, count, d, fileName, fileStream, fileType, handleFailure, params, responseSent;
    next = share.bind_env(next);
    if (!(req.method === 'POST' && !req.diced)) {
      next();
      return;
    }
    req.diced = true;
    responseSent = false;
    handleFailure = function(msg, err, retCode) {
      if (err == null) {
        err = "";
      }
      if (retCode == null) {
        retCode = 500;
      }
      console.error(msg + " \n", err);
      if (!responseSent) {
        responseSent = true;
        res.writeHead(retCode, share.defaultResponseHeaders);
        return res.end();
      }
    };
    boundary = find_mime_boundary(req);
    if (!boundary) {
      handleFailure("No MIME multipart boundary found for dicer");
      return;
    }
    params = {};
    count = 0;
    fileStream = null;
    fileType = 'text/plain';
    fileName = 'blob';
    d = new dicer({
      boundary: boundary
    });
    d.on('part', function(p) {
      p.on('header', function(header) {
        var RE_FILE, RE_PARAM, data, k, param, re, ref, v;
        RE_FILE = /^form-data; name="file"; filename="([^"]+)"/;
        RE_PARAM = /^form-data; name="([^"]+)"/;
        for (k in header) {
          v = header[k];
          if (k === 'content-type') {
            fileType = v;
          }
          if (k === 'content-disposition') {
            if (re = RE_FILE.exec(v)) {
              fileStream = p;
              fileName = re[1];
            } else if (param = (ref = RE_PARAM.exec(v)) != null ? ref[1] : void 0) {
              data = '';
              count++;
              p.on('data', function(d) {
                return data += d.toString();
              });
              p.on('end', function() {
                count--;
                params[param] = data;
                if (count === 0 && fileStream) {
                  req.multipart = {
                    fileStream: fileStream,
                    fileName: fileName,
                    fileType: fileType,
                    params: params
                  };
                  responseSent = true;
                  return next();
                }
              });
            } else {
              console.warn("Dicer part", v);
            }
          }
        }
        if (count === 0 && fileStream) {
          req.multipart = {
            fileStream: fileStream,
            fileName: fileName,
            fileType: fileType,
            params: params
          };
          responseSent = true;
          return next();
        }
      });
      return p.on('error', function(err) {
        return handleFailure('Error in Dicer while parsing multipart:', err);
      });
    });
    d.on('error', function(err) {
      return handleFailure('Error in Dicer while parsing parts:', err);
    });
    d.on('finish', function() {
      if (!fileStream) {
        return handleFailure("Error in Dicer, no file found in POST");
      }
    });
    return req.pipe(d);
  };
  post = function(req, res, next) {
    var stream;
    if (req.multipart.fileType) {
      req.gridFS.contentType = req.multipart.fileType;
    }
    if (req.multipart.fileName) {
      req.gridFS.filename = req.multipart.fileName;
    }
    stream = this.upsertStream(req.gridFS);
    if (stream) {
      return req.multipart.fileStream.pipe(share.streamChunker(this.chunkSize)).pipe(stream).on('close', function(retFile) {
        if (retFile) {
          res.writeHead(200, share.defaultResponseHeaders);
          return res.end();
        }
      }).on('error', function(err) {
        res.writeHead(500, share.defaultResponseHeaders);
        return res.end();
      });
    } else {
      res.writeHead(410, share.defaultResponseHeaders);
      return res.end();
    }
  };
  get = function(req, res, next) {
    var chunksize, end, filename, h, headers, parts, ref, ref1, since, start, statusCode, stream, v;
    headers = {};
    ref = share.defaultResponseHeaders;
    for (h in ref) {
      v = ref[h];
      headers[h] = v;
    }
    if (req.headers['if-modified-since']) {
      since = Date.parse(req.headers['if-modified-since']);
      if (since && req.gridFS.uploadDate && (req.headers['if-modified-since'] === req.gridFS.uploadDate.toUTCString() || since >= req.gridFS.uploadDate.getTime())) {
        res.writeHead(304, headers);
        res.end();
        return;
      }
    }
    if (req.headers['range']) {
      statusCode = 206;
      parts = req.headers["range"].replace(/bytes=/, "").split("-");
      start = parseInt(parts[0], 10);
      end = (parts[1] ? parseInt(parts[1], 10) : req.gridFS.length - 1);
      if ((start < 0) || (end >= req.gridFS.length) || (start > end) || isNaN(start) || isNaN(end)) {
        headers['Content-Range'] = 'bytes ' + '*/' + req.gridFS.length;
        res.writeHead(416, headers);
        res.end();
        return;
      }
      chunksize = (end - start) + 1;
      headers['Content-Range'] = 'bytes ' + start + '-' + end + '/' + req.gridFS.length;
      headers['Accept-Ranges'] = 'bytes';
      headers['Content-Type'] = req.gridFS.contentType;
      headers['Content-Length'] = chunksize;
      headers['Last-Modified'] = req.gridFS.uploadDate.toUTCString();
      if (req.method !== 'HEAD') {
        stream = this.findOneStream({
          _id: req.gridFS._id
        }, {
          range: {
            start: start,
            end: end
          }
        });
      }
    } else {
      statusCode = 200;
      headers['Content-Type'] = req.gridFS.contentType;
      headers['Content-MD5'] = req.gridFS.md5;
      headers['Content-Length'] = req.gridFS.length;
      headers['Last-Modified'] = req.gridFS.uploadDate.toUTCString();
      if (req.method !== 'HEAD') {
        stream = this.findOneStream({
          _id: req.gridFS._id
        });
      }
    }
    if ((req.query.download && req.query.download.toLowerCase() === 'true') || req.query.filename) {
      filename = encodeURIComponent((ref1 = req.query.filename) != null ? ref1 : req.gridFS.filename);
      headers['Content-Disposition'] = "attachment; filename=\"" + filename + "\"; filename*=UTF-8''" + filename;
    }
    if (req.query.cache && !isNaN(parseInt(req.query.cache))) {
      headers['Cache-Control'] = "max-age=" + parseInt(req.query.cache) + ", private";
    }
    if (req.method === 'HEAD') {
      res.writeHead(204, headers);
      res.end();
      return;
    }
    if (stream) {
      res.writeHead(statusCode, headers);
      return stream.pipe(res).on('close', function() {
        return res.end();
      }).on('error', function(err) {
        res.writeHead(500, share.defaultResponseHeaders);
        return res.end(err);
      });
    } else {
      res.writeHead(410, share.defaultResponseHeaders);
      return res.end();
    }
  };
  put = function(req, res, next) {
    var stream;
    if (req.headers['content-type']) {
      req.gridFS.contentType = req.headers['content-type'];
    }
    stream = this.upsertStream(req.gridFS);
    if (stream) {
      return req.pipe(share.streamChunker(this.chunkSize)).pipe(stream).on('close', function(retFile) {
        if (retFile) {
          res.writeHead(200, share.defaultResponseHeaders);
          return res.end();
        } else {

        }
      }).on('error', function(err) {
        res.writeHead(500, share.defaultResponseHeaders);
        return res.end(err);
      });
    } else {
      res.writeHead(404, share.defaultResponseHeaders);
      return res.end(req.url + " Not found!");
    }
  };
  del = function(req, res, next) {
    this.remove(req.gridFS);
    res.writeHead(204, share.defaultResponseHeaders);
    return res.end();
  };
  build_access_point = function(http) {
    var i, len, r;
    for (i = 0, len = http.length; i < len; i++) {
      r = http[i];
      if (r.method.toUpperCase() === 'POST') {
        this.router.post(r.path, dice_multipart);
      }
      this.router[r.method](r.path, (function(_this) {
        return function(r) {
          return function(req, res, next) {
            var lookup, opts, ref, ref1, ref2;
            if (((ref = req.params) != null ? ref._id : void 0) != null) {
              req.params._id = share.safeObjectID(req.params._id);
            }
            if (((ref1 = req.query) != null ? ref1._id : void 0) != null) {
              req.query._id = share.safeObjectID(req.query._id);
            }
            lookup = (ref2 = r.lookup) != null ? ref2.bind(_this)(req.params || {}, req.query || {}, req.multipart) : void 0;
            if (lookup == null) {
              res.writeHead(500, share.defaultResponseHeaders);
              res.end();
            } else {
              req.gridFS = _this.findOne(lookup);
              if (!req.gridFS) {
                res.writeHead(404, share.defaultResponseHeaders);
                res.end();
                return;
              }
              switch (req.method) {
                case 'HEAD':
                case 'GET':
                  if (!share.check_allow_deny.bind(_this)('read', req.meteorUserId, req.gridFS)) {
                    res.writeHead(403, share.defaultResponseHeaders);
                    res.end();
                    return;
                  }
                  break;
                case 'POST':
                case 'PUT':
                  req.maxUploadSize = _this.maxUploadSize;
                  if (!(opts = share.check_allow_deny.bind(_this)('write', req.meteorUserId, req.gridFS))) {
                    res.writeHead(403, share.defaultResponseHeaders);
                    res.end();
                    return;
                  }
                  if ((opts.maxUploadSize != null) && typeof opts.maxUploadSize === 'number') {
                    req.maxUploadSize = opts.maxUploadSize;
                  }
                  if (req.maxUploadSize > 0) {
                    if (req.headers['content-length'] == null) {
                      res.writeHead(411, share.defaultResponseHeaders);
                      res.end();
                      return;
                    }
                    if (!(parseInt(req.headers['content-length']) <= req.maxUploadSize)) {
                      res.writeHead(413, share.defaultResponseHeaders);
                      res.end();
                      return;
                    }
                  }
                  break;
                case 'DELETE':
                  if (!share.check_allow_deny.bind(_this)('remove', req.meteorUserId, req.gridFS)) {
                    res.writeHead(403, share.defaultResponseHeaders);
                    res.end();
                    return;
                  }
                  break;
                case 'OPTIONS':
                  if (!(share.check_allow_deny.bind(_this)('read', req.meteorUserId, req.gridFS) || share.check_allow_deny.bind(_this)('write', req.meteorUserId, req.gridFS) || share.check_allow_deny.bind(_this)('remove', req.meteorUserId, req.gridFS))) {
                    res.writeHead(403, share.defaultResponseHeaders);
                    res.end();
                    return;
                  }
                  break;
                default:
                  res.writeHead(500, share.defaultResponseHeaders);
                  res.end();
                  return;
              }
              return next();
            }
          };
        };
      })(this)(r));
      if (typeof r.handler === 'function') {
        this.router[r.method](r.path, r.handler.bind(this));
      }
    }
    return this.router.route('/*').all(function(req, res, next) {
      if (req.gridFS != null) {
        next();
      } else {
        res.writeHead(404, share.defaultResponseHeaders);
        return res.end();
      }
    }).head(get.bind(this)).get(get.bind(this)).put(put.bind(this)).post(post.bind(this))["delete"](del.bind(this)).all(function(req, res, next) {
      res.writeHead(500, share.defaultResponseHeaders);
      return res.end();
    });
  };
  lookup_userId_by_token = function(authToken) {
    var ref, userDoc;
    userDoc = (ref = Meteor.users) != null ? ref.findOne({
      'services.resume.loginTokens': {
        $elemMatch: {
          hashedToken: typeof Accounts !== "undefined" && Accounts !== null ? Accounts._hashLoginToken(authToken) : void 0
        }
      }
    }) : void 0;
    return (userDoc != null ? userDoc._id : void 0) || null;
  };
  handle_auth = function(req, res, next) {
    var ref, ref1;
    if (req.meteorUserId == null) {
      if (((ref = req.headers) != null ? ref['x-auth-token'] : void 0) != null) {
        req.meteorUserId = lookup_userId_by_token(req.headers['x-auth-token']);
      } else if (((ref1 = req.cookies) != null ? ref1['X-Auth-Token'] : void 0) != null) {
        req.meteorUserId = lookup_userId_by_token(req.cookies['X-Auth-Token']);
      } else {
        req.meteorUserId = null;
      }
    }
    return next();
  };
  share.setupHttpAccess = function(options) {
    var h, i, len, otherHandlers, r, ref, ref1, resumableHandlers;
    if (options.resumable) {
      if (options.http == null) {
        options.http = [];
      }
      resumableHandlers = [];
      otherHandlers = [];
      ref = options.http;
      for (i = 0, len = ref.length; i < len; i++) {
        h = ref[i];
        if (h.path === share.resumableBase) {
          resumableHandlers.push(h);
        } else {
          otherHandlers.push(h);
        }
      }
      resumableHandlers = resumableHandlers.concat(share.resumablePaths);
      options.http = resumableHandlers.concat(otherHandlers);
    }
    if (((ref1 = options.http) != null ? ref1.length : void 0) > 0) {
      r = express.Router();
      r.use(express.query());
      r.use(cookieParser());
      r.use(handle_auth);
      WebApp.rawConnectHandlers.use(this.baseURL, share.bind_env(r));
      this.router = express.Router();
      build_access_point.bind(this)(options.http, this.router);
      return WebApp.rawConnectHandlers.use(this.baseURL, share.bind_env(this.router));
    }
  };
}
